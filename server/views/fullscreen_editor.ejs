<html>
<head>
<script src="/hotkeys.min.js"></script>
<script src="/ace/ace.js"></script>
<script src="/noty.js"></script>
<script src="/notyq.js"></script>
<script src="/xterm.js"></script>
<script src="/xterm-addon-fit.js"></script>
<script src="/xterm-addon-web-links.js"></script>
<script src="/xterm-theme.js"></script>
<script src="/xterm-addon-search.js"></script>
<script src="/xterm-addon-search-bar.js"></script>
<script src="/sweetalert2.js"></script>
<script src="/Socket.js"></script>
<script src="/common.js"></script>
<script src="/he.js"></script>
<script src="/opener.js"></script>
<script src="/nav.js"></script>
<script src="/autoexpand.js"></script>
<script src="/modalinput.js"></script>
<script src="/notifyinput.js"></script>
<script src="/report.js"></script>
<link href="/xterm.min.css" rel="stylesheet" />
<link href="/css/fontawesome.min.css" rel="stylesheet">
<link href="/css/solid.min.css" rel="stylesheet">
<link href="/css/regular.min.css" rel="stylesheet">
<link href="/css/brands.min.css" rel="stylesheet">
<link href="/style.css" rel="stylesheet"/>
<link href="/noty.css" rel="stylesheet"/>
<% if (agent === "electron") { %>
  <link href="/electron.css" rel="stylesheet"/>
<% } %>
<style>
html {
  scroll-behavior: smooth;
  height: 100%;
  overflow: hidden;
}

body {
  height: 100%;
  overflow: hidden;
  background: rgb(44, 29, 22);
  display: flex;
  flex-direction: column;
}
#table > table {
  border-left: 2px solid black;
  padding-left: 5px;
  margin: 10px 0;
}
.highlight {
  background: yellow;
  width: 100px;
}
th {
  background: rgba(0,0,0,0.1);
  padding: 10px;
  font-size: 12px;
}
td {
  font-size: 12px;
  padding: 10px;
}
td.val {
  background: rgba(0,0,0,0.06);
}
td.key {
  background: rgba(0,0,0,0.1);
}
.button {
  cursor: pointer; 
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
}
header {
  position: relative;
}
.button:hover {
  
}
#terminal {
  flex-grow: 1;
}
.terminal {
  box-sizing: border-box;
}
.xterm .xterm-viewport {
  width: initial !important;
}
</style>
<script>
document.addEventListener("DOMContentLoaded", async () => {
  <% if (requirements_pending) { %>
    await new Promise((resolve, reject) => {
      let interval = setInterval(() => {
        fetch("/pinokio/requirements_ready").then((res) => {
          return res.json()
        }).then((res) => {
          console.log(res)
          if (!res.requirements_pending) {
            clearInterval(interval)
            resolve()
          }
        })
      }, 500)
    })
    location.href = location.href
  <% } %>
  const n = new N()
  class RPC {
    constructor() {
      this.socket = new Socket()
    }
    finished() {
    /*
      n.Noty({
        text: `[Success] All steps complete`,
      })
      */
      document.querySelector(".run .play").classList.remove("hidden")
      document.querySelector(".run .stop").classList.add("hidden")
      document.querySelector(".run .starting").classList.add("hidden")
    }
    stop() {
      this.socket.run({
        method: "kernel.api.stop",
        params: {
          //uri: "<%-uri%>",
          //uri: location.pathname.slice(1).replace("api/", ""),
          uri: "~" + location.pathname
        }
      }, (stream) => {
      })
    }
    save() {
      return new Promise((resolve, reject) => {
        let cwd = "~" + location.pathname

        this.socket.close()
        this.socket.run({
          method: "fs.write",
          params: {
            path: cwd,
            text: str,
//            string: str
//            json: instructions
          }
        }, (packet) => {
          if (packet.type === "result" && packet.id === "fs.write") {
            dirty = false
            document.querySelector("#save").classList.add("disabled")
            resolve()
          }
        })
      })
    }
    start(mode) {
      return new Promise(async (resolve, reject) => {
//        await this.save()
        await this.socket.close()
        this.socket.run({
          //uri: location.pathname.slice(1).replace("api/", ""),
          uri: "~" + location.pathname,
          //uri: "<%-uri%>",
          mode,
          client: {
            cols: this.term.cols,
            rows: this.term.rows,
          }
        }, async (packet) => {
          if (packet.type === "stream") {
            if (packet.data.raw) {
              this.term.write(packet.data.raw)
            } else if (packet.data.json) {
              this.term.write(JSON.stringify(packet.data.json).replace(/\n/g, "\r\n"))
              this.term.write("\r\n")
            } else if (packet.data.json2) {
              this.term.write(JSON.stringify(packet.data.json2, null, 2).replace(/\n/g, "\r\n"))
              this.term.write("\r\n")
            }
            document.querySelector(".run .play").classList.add("hidden")
            document.querySelector(".run .starting").classList.add("hidden")
            document.querySelector(".run .stop").classList.remove("hidden")
          } else if (packet.type === 'disconnect') {
            this.term.write("\r\nDisconnected...\r\n")
          } else if (packet.type === 'connect') {
            const message = "..........Connected!\r\n"
            this.term.write(message)
            /*
            for(let i=0; i<message.length; i++) {
              await new Promise((r, reject) => {
                setTimeout(()=> {
                  this.term.write(message[i])
                  r()
                }, 20)
              })
            }
            */
            document.querySelector(".run .play").classList.add("hidden")
            document.querySelector(".run .starting").classList.add("hidden")
            document.querySelector(".run .stop").classList.remove("hidden")
          } else if (packet.type === "input") {
            let params = packet.data
            let type = (params.type ? params.type : "modal")
            let input
            if (type === "modal") {
              input = await ModalInput(packet.data)
            } else if (type === "notify") {
              input = await NotifyInput(packet.data, n)
            }
            if (input) {
              this.socket.respond({
                response: input,
                uri: "~" + location.pathname,
              })
            }
            /*
              params := {
                title,
                description,
                form: [{
                  title,
                  description
                }]
              }
            */
          } else if (packet.type === "browser.open") {
          /*
            {
              "method": "browser.open",
              "params": {
                "uri",
                "target": "_self (default)"|"_blank"|"_parent"|"_top",
                "features"
              }
            }
            */
            let params = packet.data
            window.open(
              params.uri,
              (params.target || "_self"),
              params.features
            )
          } else if (packet.type === "browser.close") {
            let params = packet.data
            if (params && params.target) {
              let targetWindow = window.open('', params.target)
              if (targetWindow) {
                targetWindow.close();
              }
            } else {
              window.close()
            }
          } else if (packet.type === "browser") {
          /*
            {
              "method": "browser.close"
            }
          */
            let { method, params } = packet.data
            let resolved = window
            let tokens = method.split(".")
            for(let token of tokens) {
              resolved = resolved[token]
            }
            let result = resolved(...params)
          } else if (packet.type === "notify") {
          /*
            {
              html: <notification html>,
              href: <link location to open>,
              target: <target for window.open()>,
              features: <windowFeatures>, ("self" => opens in pinokio)
            }
          */
            if (packet.data) {
              let payload = {}
              if (packet.data.html) {
                payload.text = packet.data.html
              }
              if (packet.data.type) {
                payload.type = packet.data.type
              }
              payload.callbacks = {
                onClick: () => {
                  let params = packet.data
                  if (params.href || params.uri) {
                    window.open(
                      params.uri || params.href,
                      (params.target || "_self"),
                      params.features
                    )
                  } else if (params.action === "close") {
                    if (params && params.target) {
                      let targetWindow = window.open('', params.target)
                      if (targetWindow) {
                        targetWindow.close();
                      }
                    } else {
                      window.close()
                    }
                  }
                }
              }
              n.Noty(payload)
            }
          } else if (packet.type === "result") {
          } else if (packet.type === "info") {
            n.Noty({
              text: `${packet.data}`,
            })
          } else if (packet.type === "error") {
            n.Noty({
              text: `${packet.data}`,
              type: "error"
            })
            this.socket.close()

            document.querySelector(".run .play").classList.remove("hidden")
            document.querySelector(".run .starting").classList.add("hidden")
            document.querySelector(".run .stop").classList.add("hidden")

          } else if (packet.type === "event") {
            if (packet.data === "stop") {
              setTimeout(() => {

                let params = new URLSearchParams(location.search)
                let entries = [...params.entries()]
                let options;
                if (entries.length > 0) {
                  options = {}
                  for(const [key, value] of entries) {
                    options[key] = value;
                  }
                }
                if (options && options.html) {
                  n.Noty({
                    text: options.html,
                    callbacks: {
                      onClose: () => {
                        let uri = options.uri || options.href
                        if (uri) {
                          let target = options.target || "_self"
                          let features = options.features
                          window.open(uri, target, features)
                        } else if (options.action === "close") {
                          window.close()
                        }
                      }
                    }
                  })
                }
              /*
                n.Noty({
                  text: '[Notice] finished',
                  type: 'success'
                })
                */
                document.querySelector(".run .play").classList.remove("hidden")
                document.querySelector(".run .starting").classList.add("hidden")
                document.querySelector(".run .stop").classList.add("hidden")
              }, 0)
              this.socket.close()
            }
          }

          // Get the available space for the terminal
//          let terminalContainer = document.querySelector("#terminal")
//          const availableHeight = terminalContainer.clientHeight;
//
//          // Calculate the number of columns and rows the terminal should have
//          console.log(this.term)
//          //const rows = Math.floor(availableHeight / this.term._core.viewport._charSizeService.height);
//          const rows = Math.floor(this.term._core.viewport._lastRecordedViewportHeight / this.term._core.viewport._charSizeService.height);
//
//
//          // Resize the terminal
//          this.term.resize(this.term.cols, rows);
//          this.term.scrollToLine(this.term.rows-1);
//          this.fit.fit()
//          let pageBottom = document.querySelector("#end")
//          pageBottom.scrollIntoView()
        })
      })
    }
    async run (mode) {
      this.mode = (mode ? mode : "run")
      
//      if (dirty) {
//        await this.save()
//        n.Noty({
//          text: `script updated`,
//        })
//      }

      await this.createTerm()
      await this.start(mode)
    }
    createTerm () {
      if (!this.term) {
        const term = new Terminal({
          //theme: xtermTheme.Piatto_Light,
          //theme: xtermTheme.Spring,

          //theme: xtermTheme.Github,

          //theme: xtermTheme.Cobalt_Neon,      // top legibility
          theme: xtermTheme.Duotone_Dark,
          //theme: xtermTheme.Seafoam_Pastel,
          //theme: xtermTheme.IC_Green_PPL,
          //theme: xtermTheme.FunForrest,
          //theme: xtermTheme.Jackie_Brown,
          //theme: xtermTheme.Ocean,

          //theme: xtermTheme.Blazer,
          //theme: xtermTheme.BirdsOfParadise,
          //theme: xtermTheme.AtelierSulphurpool,
          //theme: xtermTheme.Borland,
          fontSize: 12,
          //cursorBlink: false,
          //cursorStyle: 'block'

        });
        term.open(document.querySelector("#terminal"))

        term.attachCustomKeyEventHandler(event => {
          if (event.ctrlKey && event.key === 'c' && term.hasSelection()) {
            return false;
          }
          if (event.ctrlKey && event.key === 'v' && this._options.pasteWithCtrlV) {
            return false;
          }
          return true;
        });
        //const rows = Math.floor(document.querySelector("#terminal").clientHeight / term._core.viewport._charSizeService.height);
        //const cols = Math.floor(document.querySelector("#terminal").clientHeight / term._core.viewport._charSizeService.width);
        //console.log(cols, term.cols)
        //  // Resize the terminal
        ////term.resize(cols, rows-5);
        //term.resize(cols, rows);

        const fitAddon = new FitAddon.FitAddon();
//        const searchAddon = new SearchAddon.SearchAddon();
//        const searchAddonBar = new SearchBarAddon.SearchBarAddon({searchAddon});
        term.loadAddon(fitAddon);
        <% if (agent === "electron") { %>
          term.loadAddon(new WebLinksAddon.WebLinksAddon((event, uri) => {
            window.open(uri, "_blank")
          }))
        <% } else { %>
          term.loadAddon(new WebLinksAddon.WebLinksAddon());
        <% } %>
//        term.loadAddon(searchAddon)
//        term.loadAddon(searchAddonBar);
//        searchAddonBar.show();
        fitAddon.fit();
        this.fit = fitAddon
        this.term = term
      }
      this.term.focus()
    }
  }
  <% if (!install_required) { %>
    const rpc = new RPC()

    <% if (mod && runnable) { %>
      document.querySelector(".stop").addEventListener("click", async (e) => {
        await rpc.stop()
    //    socket.run({
    //      id: location.pathname,
    //      method: "kernel.api.stop"
    //    }, (stream) => {
    //      console.log("#", stream)
    //    })
        document.querySelector(".run .play").classList.remove("hidden")
        document.querySelector(".run .starting").classList.add("hidden")
        document.querySelector(".run .stop").classList.add("hidden")
      })
      document.querySelector(".play").addEventListener("click", async (e) => {
        document.querySelector(".run .play").classList.add("hidden")
        document.querySelector(".run .starting").classList.remove("hidden")
        await rpc.run()
      })
    <% } %>
    document.querySelector("#save").addEventListener("click", async (e) => {
      console.log("SAVE")
      await rpc.save()
      n.Noty({
        text: `saved`,
      })
    })
    <% if (stop) { %>
      await rpc.stop()
      document.querySelector(".run .play").classList.remove("hidden")
      document.querySelector(".run .starting").classList.add("hidden")
      document.querySelector(".run .stop").classList.add("hidden")
    <% } else { %>
      <% if (run) { %>
        // run (query params run=true)
        document.querySelector(".run .play").classList.add("hidden")
        document.querySelector(".run .starting").classList.remove("hidden")
        rpc.run()
      <% } else { %>
        rpc.run("listen")
      <% } %>
    <% } %>
  <% } %>
  document.querySelector("#explore").addEventListener("click", async (e) => {
    e.preventDefault()
    e.stopPropagation()
    location.href = "/?mode=explore"
  })
  Reporter()
})
</script>
</head>
<% if (install_required) { %>
<body class='frozen <%=theme%>'>
<% } else { %>
<body class='<%=theme%>'>
<% } %>
  <header>
  <h1>
  <% paths.forEach((path) => { %>
    <% if (path.action) { %>
      <a class='path nav-button' id="<%=path.id%>" onclick="<%=path.action%>"><%-path.name%></a>
    <% } else if (path.path) { %>
      <a class='path' href="<%=path.path%>"><%-path.name%></a>
    <% } %>
  <% }) %>
  <div class='flexible'></div>
  <button class='btn2' id='explore'><div><i class="fa-solid fa-globe"></i></div><div>Discover</div></button>
  <button class='btn2' id='report'><div><i class="fa-solid fa-bug"></i></div><div>Report Bug</div></button>
  <button id='new-window' title='open a new window'><i class="fa-solid fa-plus"></i></button>
  </h1>
  <a class='gitremote' data-filepath="<%=filepath%>"><%=filepath%></a>
  <% if (pinokioPath) { %>
  <div class='pinokiourl'><i class="fa-solid fa-link"></i><%=pinokioPath%></div>
  <% } %>
  <% if (!install_required) { %>
    <div class='runner'>
      <div class='btn run <%= mod && runnable ? "" : "hidden" %>'>
        <span class='play'><i class="fa-solid fa-play"></i> Run</span>
        <span class='starting hidden'><i class="fa-solid fa-circle-notch fa-spin"></i> Starting...</span>
        <span class='stop hidden'><i class="fa-solid fa-stop"></i> Stop</span>
      </div>
      <div id='save' class='btn disabled'>
        <span class='save'><i class="fa-solid fa-check"></i> Save</span>
      </div>
    </div>
  <% } %>
  </header>
  <% if (requirements_pending) { %>
    <div class='requirements'>
      <div class='content'>
        <div class='loading'>
          <i class="fa-solid fa-circle-notch fa-spin"></i>
        </div>
      </div>
    </div>
  <% } else { %>
    <% if (install_required) { %>
      <div class='requirements'>
        <div class='content'>
          <div class='title'><i class="fa-solid fa-circle-exclamation"></i> Installation required</div>
          <div class='btn-group'>
            <% requirements.map((r) => { %>
              <div class='requirement-item'>
                <% if (r.installed) { %>
                  <div class='name'><%=r.type ? `${r.type} : ${r.name}` : r.name%></div>
                  <div class='flexible'></div>
                  <div class='label'>Installed</div>
                <% } else { %>
                  <div class='name highlighted'><%=r.type ? `${r.type} : ${r.name}` : r.name%></div>
                  <div class='flexible'></div>
                  <div class='label highlighted'>Not Installed</div>
                <% } %>
              </div>
            <% }) %>
          </div>
          <form method="post" action="/pinokio/install">
            <input type='hidden' name="requirements" value="<%=JSON.stringify(requirements)%>">
            <input type='hidden' name='callback' value="<%=current%>">
            <button class='btn'>Install</button>
          </form>
        </div>
      </div>
    <% } else { %>
      <div id='terminal'></div>
      <main></main>
    <% } %>
  <% } %>
</body>
</html>
